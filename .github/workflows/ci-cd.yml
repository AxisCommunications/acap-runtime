# yamllint disable rule:line-length
---
name: CI/CD workflow.

# Run the workflow on when code or a semver tag is pushed to main branch,
# and on pull requests towards main branch
on:
  push:
    branches:
      - 'main'
    tags:
      # semver, e.g. 1.2.0 (does no match 0.1.2)
      - '[1-9]+.[0-9]+.[0-9]+'
      # semver with prerelease info, e.g. 1.0.2-beta.1 or 1.2.3-rc.10
      - '[1-9]+.[0-9]+.[0-9]+-[a-z]+.[0-9]+'
      # do not match prerelease starting w/ 0, e.g. 1.0.2-beta.0 or 1.2.3-rc.01
      - '![1-9]+.[0-9]+.[0-9]+-[a-z]+.[0]*'
      # semver with date info, e.g. 1.0.2-20221125
      - '[1-9]+.[0-9]+.[0-9]+-[0-9]+'
      # do not match date starting w/ 0, e.g. 1.0.2-01232023
      - '![1-9]+.[0-9]+.[0-9]+-[0]*'
  pull_request:
    branches:
      - 'main'

# Environment variables that are valid for all jobs
env:
  DOCKER_HUB_REPOSITORY: 'axisecp/acap-runtime'

jobs:
  # Build and run the test suite
  build_and_test:
    name: Build and run test image
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [armv7hf, aarch64]
    # Environment variables that are used by the pytest script
    env:
      AXIS_TARGET_ADDR_ARMV7HF: "${{ secrets.DEVICE_SRVR_IP }}/camera1"
      AXIS_TARGET_ADDR_AARCH64: "${{ secrets.DEVICE_SRVR_IP }}/camera2"
      AXIS_TARGET_USER: ${{ secrets.DEVICE_USER }}
      AXIS_TARGET_PASS: ${{ secrets.DEVICE_SRVR_PASS }}
      AXIS_EXTERNAL_POOL: true
    steps:
      - name: Checkout repo
        # sha for actions/checkout@v3 at time of commit.
        uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c
      - name: Create test image metadata
        id: meta_test
        uses: ./.github/actions/metadata-action
        with:
          suffix: -${{ matrix.arch }}-test
          repository: ${{ env.DOCKER_HUB_REPOSITORY }}
          latest: 'false'
          get_version: 'true'
      - name: Update manifest file
        if: ( github.ref_type == 'tag')
        uses: ./.github/actions/update-acap-manifest-action
        with:
          manifest_file: ./manifest-test.json
          value: ${{ steps.meta_test.outputs.version }}
      - name: Build test image
        uses: ./.github/actions/docker-build-push-action
        with:
          dockerfile: Dockerfile.${{ matrix.arch }}
          tags: ${{ steps.meta_test.outputs.tags }}
          labels: ${{ steps.meta_test.outputs.labels }}
          push: true
          build-args: TEST=true
          target: runtime-base
          registry_user: ${{ secrets.ECOSYSTEM_SERVICE_USER_DOCKER_HUB }}
          registry_token: ${{ secrets.ECOSYSTEM_ACCESS_TOKEN_DOCKER_HUB }}
      - name: Pull test image
        shell: bash
        run: |
          docker pull ${{ steps.meta_test.outputs.full_name }}
      - name: Set environment variables for test
        shell: bash
        run: |
          echo "AXIS_TARGET_ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          if [ ${{ matrix.arch }} = armv7hf ]
          then
            echo "AXIS_TARGET_ADDR=${{ env.AXIS_TARGET_ADDR_ARMV7HF }}" >> $GITHUB_ENV
          elif [ ${{ matrix.arch }} = aarch64 ]
          then
            echo "AXIS_TARGET_ADDR=${{ env.AXIS_TARGET_ADDR_AARCH64 }}" >> $GITHUB_ENV
          else
            echo "::error::Non valid architecture '${{ matrix.arch }}' encountered"
          fi
          echo "ACAP_DOCKER_IMAGE_NAME=${{ steps.meta_test.outputs.full_name }}" >> $GITHUB_ENV
      - name: Run the test image
        uses: ./.github/actions/pytest-action
        with:
          testfile: ./.github/test/test_acapruntimetest.py
          requirements_file: ./.github/test/requirements.txt
          logfile: test_log_${{ matrix.arch }}.txt

  # Build base and containerized images and push to Docker Hub
  # This job is skipped if not on main branch or if build_and_test job has failed
  build_and_push:
    name: Build and push images
    runs-on: ubuntu-latest
    needs: build_and_test
    if: (github.event_name != 'pull_request')
    strategy:
      matrix:
        arch: [armv7hf, aarch64]
    outputs:
      TAG: ${{ steps.vars.outputs.TAG }}
      EAP_FILE: ${{ steps.get_eap_file_name.outputs.EAP_FILE }}
      EAP_FILE_ARMV7HF: ${{ steps.save_full_file_name.outputs.EAP_FILE_ARMV7HF }}
      EAP_FILE_AARCH64: ${{ steps.save_full_file_name.outputs.EAP_FILE_AARCH64 }}
    steps:
      - name: Set output
        id: vars
        run: echo "TAG=${GITHUB_REF#refs/*/}" >> ${GITHUB_OUTPUT}
      - name: Checkout repo
        # sha for actions/checkout@v3 at time of commit.
        uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c
      - name: Create base image metadata
        id: meta
        uses: ./.github/actions/metadata-action
        with:
          suffix: -${{ matrix.arch }}
          repository: ${{ env.DOCKER_HUB_REPOSITORY }}
          get_version: 'true'
      - name: Update manifest file
        if: ( github.ref_type == 'tag')
        uses: ./.github/actions/update-acap-manifest-action
        with:
          manifest_file: ./manifest-${{ matrix.arch }}.json
          value: ${{ steps.meta.outputs.version }}
      - name: Build and push base image
        uses: ./.github/actions/docker-build-push-action
        with:
          dockerfile: Dockerfile.${{ matrix.arch }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          target: runtime-base
          push: false
          load: true
      - name: Get EAP from base image
        id: get_eap_file_name
        run: |
          docker cp $(docker create "${{ steps.meta.outputs.full_name }}"):/opt/app .build
          export EAP_FILE=$(find .build -type f -name "*.eap" -printf "%f\n")
          delimiter="$(openssl rand -hex 8)"
          echo "EAP_FILE<<${delimiter}" >> ${GITHUB_OUTPUT}
          echo "${EAP_FILE}" >> ${GITHUB_OUTPUT}
          echo "${delimiter}" >> ${GITHUB_OUTPUT}
      - name: Sign eap-file
        run: |
          cd .build
          curl -XPOST -H 'accept: */*' -H 'Content-Type: multipart/form-data' -H 'Authorization: Bearer ${{secrets.ACAP_PORTAL_SIGNING_BEARER_TOKEN}}' \
          'https://gw.ext.csi-api.axis.com/ext/acap/admin/application/${{secrets.ACAP_PORTAL_SIGNING_ID}}/sign/binary' -F uploadedFile=@"${{ steps.get_eap_file_name.outputs.EAP_FILE }}" --output Signed_${{ steps.get_eap_file_name.outputs.EAP_FILE }}
      - name: Upload artifact
        uses: actions/upload-artifact@0b7f8abb1508181956e8e162db84b466c27e18ce
        with:
          name: Signed_${{ steps.get_eap_file_name.outputs.EAP_FILE }}
          path: .build/Signed_${{ steps.get_eap_file_name.outputs.EAP_FILE }}
          if-no-files-found: error
      - name: Save file name
        id: save_full_file_name
        run: |
          if [ ${{ matrix.arch }} = armv7hf ]
          then
            echo "EAP_FILE_ARMV7HF=Signed_${{ steps.get_eap_file_name.outputs.EAP_FILE }}" >> $GITHUB_OUTPUT
          elif [ ${{ matrix.arch }} = aarch64 ]
          then
            echo "EAP_FILE_AARCH64=Signed_${{ steps.get_eap_file_name.outputs.EAP_FILE }}" >> $GITHUB_OUTPUT
          else
            echo "::error::Non valid architecture '${{ matrix.arch }}' encountered"
          fi
      - name: Create containerized image metadata
        id: meta_containerized
        uses: ./.github/actions/metadata-action
        with:
          suffix: -${{ matrix.arch }}-containerized
          repository: ${{ env.DOCKER_HUB_REPOSITORY }}
      - name: Build and push containerized image
        uses: ./.github/actions/docker-build-push-action
        with:
          dockerfile: Dockerfile.${{ matrix.arch }}
          tags: ${{ steps.meta_containerized.outputs.tags }}
          labels: ${{ steps.meta_containerized.outputs.labels }}
          push: true
          build-args: |
              ARCH=${{ matrix.arch }}
              RUNTIME_VERSION=${{ steps.meta.outputs.version }}
          use_qemu: 'true'
          registry_user: ${{ secrets.ECOSYSTEM_SERVICE_USER_DOCKER_HUB }}
          registry_token: ${{ secrets.ECOSYSTEM_ACCESS_TOKEN_DOCKER_HUB }}

  create_prerelease:
    permissions: write-all
    runs-on: ubuntu-latest
    needs: build_and_push
    outputs:
      RELEASE_ID: ${{ steps.prerelease.outputs.RELEASE_ID }}
    env:
      TAG: ${{ needs.build_and_push.outputs.TAG }}
    steps:
    - name: Create prerelease
      id: prerelease
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        export RELEASE_ID=$( jq -r '.id' <<< $(
        gh api \
        --method POST \
        -H "Accept: application/vnd.github+json" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        /repos/AxisCommunications/acap-runtime/releases \
        -f tag_name='${{ env.TAG }}' \
        -f target_commitish='main' \
        -f name='${{ env.TAG }}' \
        -f body='Prerelease for ${{ env.TAG }}' \
        -F draft=false \
        -F prerelease=true \
        -F generate_release_notes=false
          ))
        delimiter="$(openssl rand -hex 8)"
        echo "RELEASE_ID<<${delimiter}" >> ${GITHUB_OUTPUT}
        echo "${RELEASE_ID}" >> ${GITHUB_OUTPUT}
        echo "${delimiter}" >> ${GITHUB_OUTPUT}
        echo "RELEASE_ID ${RELEASE_ID}"

        if [[ -z ${RELEASE_ID} ]]
        then
          echo "Create prerelease was not successful"
          exit 1
        else
          echo "Create prerelease was successful, with id ${RELEASE_ID}"
        fi

  download-and-upload-artifacts:
    permissions: write-all
    runs-on: ubuntu-latest
    needs: [create_prerelease, build_and_push]
    strategy:
      matrix:
        arch: [armv7hf, aarch64]
    env:
      RELEASE_ID: ${{ needs.create_prerelease.outputs.RELEASE_ID }}
      EAP_FILE_AARCH64: ${{ needs.build_and_push.outputs.EAP_FILE_AARCH64 }}
      EAP_FILE_ARMV7HF: ${{ needs.build_and_push.outputs.EAP_FILE_ARMV7HF }}
    steps:
    - name: Get EAP file name
      id: full_eap_name
      run: |
        if [ ${{ matrix.arch }} = armv7hf ]
        then
          echo "EAP_FILE=${{ needs.build_and_push.outputs.EAP_FILE_ARMV7HF }}" >> $GITHUB_ENV
        elif [ ${{ matrix.arch }} = aarch64 ]
        then
          echo "EAP_FILE=${{ needs.build_and_push.outputs.EAP_FILE_AARCH64 }}" >> $GITHUB_ENV
        else
          echo "::error::Non valid architecture '${{ matrix.arch }}' encountered"
        fi
    - name: Download artifacts
      uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a
      with:
        name: ${{ env.EAP_FILE }}
        path: ./
    - name: Upload file to GitHub release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        RESPONSE=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.manifold-preview" \
          -H "Content-Type: application/zip" \
          --data-binary @${{ env.EAP_FILE }} \
          "https://uploads.github.com/repos/AxisCommunications/acap-runtime/releases/${{env.RELEASE_ID}}/assets?name=${{ env.EAP_FILE }}" \
          -w "%{http_code}\n" -o /dev/null)
        echo "HTTP_RESPONSE=$RESPONSE" >> $GITHUB_ENV
    - name: Check that asset has been uploaded correctly
      run: |
        if [[ -n "$HTTP_RESPONSE" && "$HTTP_RESPONSE" =~ ^[0-9]+$ ]]; then
          if [ "$HTTP_RESPONSE" -eq 201 ]; then
            echo "HTTP response code is 201, upload was succesful"
          else
            echo "HTTP response code is: $HTTP_RESPONSE, upload was not succesful"
            exit 1
          fi
        else
          echo "HTTP_RESPONSE is empty or not a valid integer: $HTTP_RESPONSE"
        fi